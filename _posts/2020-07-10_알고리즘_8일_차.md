---
title: 정렬
categories: TIL
tags: 알고리즘
---



### 정렬이란?

핵심 항목(key)의 대소 관계에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업

### 정렬 알고리즘의 안정성

정렬 알고리즘에서 안정성이란 같은 키 값인 요소의 순서가 정렬 후에도 유지되는 것을 뜻한다.

### 대표적인 정렬 알고리즘

* 버블 정렬
* 단순 선택 정렬
* 단순 삽입 정렬
* 셸 정렬
* 퀵 정렬
* 병합 정렬
* 힙 정렬
* 도수 정렬

### 내부 정렬과 외부 정렬

정렬할 모든 데이터를 하나의 배열에 저장할 수 있는 경우에 내부 정렬을 사용하고,

정렬할 데이터가 너무 많아서 하나의 배열에 저장할 수 없는 경우에 외부 정렬을 사용한다.



### 정렬 알고리즘의 핵심 요소

정렬 알고리즘의 핵심 요소는 **교환, 선택, 삽입**이며 대부분의 정렬 알고리즘은 이 세 요소를 응용한 것



### 버블 정렬 (bubble sort)

이웃한 두 요소의 대소 관계를 비교하여 교환을 반복

패스: 비교, 교환 작업

총 수행하는 패스는 요소 - 1 회이다.

```java
sttic void swap(int[] a, int idx1, idx2) {
    int t = a[idx1];
    a[idx1] = a[idx2];
    a[idx2] = t;
}
static void bubbleSort(int[] a, int n) {
    for(int i = 0; i < n-1; i++) {
        for(int j = n - 1; j > i; j--) {
            if(a[j - 1] > a[j]) {
                swap(a, j-1, j);
            }
        }  // 패스
    }    
}

```

* 버블 정렬의 평균 비교 횟수는 n(n - 1) / 2회, 평균 교환 횟수는 n(n - 1) / 4회
* 평균 이동 횟수는 3n(n - 1) / 4회이다.
* 이미 배열이 정렬을 마친 상태라면 그 이후의 패스는 요소 교환을 하지 않는다.
* 즉, 어떤 패스에서 요소의 교환 횟수가 0이면 더 이상 정렬할 요소가 없으므로 정렬 작업을 끝낸다.

```java
static void bubbleSort(int[] a, int n) {
    for(int i = 0; i < n-1; i++) {
        int exchg = 0;
        for(int j = n - 1; j > i; j--) {
            if(a[j - 1] > a[j]) {
                swap(a, j-1, j);
                exchg++;
            }
            if(exchg == 0) {  // 요소 교환이 없으면 정렬을 끝낸다.
                break; 
            }
        }  // 패스
    }    
}
```



* 각가의 패스에서 비교, 교환을 하다가 어떤 시점 이후에 교환이 수행되지 않는다면 그보다 앞쪽의 요소는 이미 정렬을 마친 상태이다.

```java
static void bubbleSort(int[] a, int n) {
    int k = 0;
    while(k < n-1) {
        int last = n - 1;
        for(int j = n - 1; j > k; j--) {
            if(a[i - 1] > a[j]) {
                swap(a, j-1, j);
                last = j;
            }
        }
        k = last;
    }
}
```

* last는 각 패스에서 마지막으로 교환한 두 요소 가운데 오른쪽 요소의 인덱스
* 하나의 패스를 마쳤을 때 last 값을 k에 대입하여 다음에 수행할 패스의 범위를 제한



### 단순 선택 정렬 (straight selection sort)

가장 작은 요소부터 선택해 알맞은위치로 옮겨서 순서대로 정렬하는 알고리즘



#### 과정

1. 아직 정렬하지 않은 부분에서 가장 작은 키의 값을 선택
2. 가장 작은 키의 값과 아직 정렬하지 않은 부분의 첫 번째 요소를 교환



```java
static void selectionSort(int[] a, int n) {
    for(int i = 0; i < n - 1; i++) {
        int min = i; // 정렬되지 않은 부분의 가장 작은 요소의 인덱스
        for(int j = i + 1; j < n; j++) {
            if(a[j] < a[min]) {
                min = j;
            }
        }
        swap(a, i, min); // 정렬되지 않은 부분의 첫 요소와 가장 작은 요소를 교환
    }
}
```

* 단순 선택 정렬의 비교 횟수는 (n^2 - n) / 2회
* 서로 떨어져있는 요소를 교환하는 것이라서 불안정하다.
* 서로 같은 값의 두 요소의 순서가 바뀔 수 있다.



### 단순 삽입 정렬 (straight insert sort)

선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 삽입하는 작업을 반복하여 정렬하는 알고리즘



#### 과정

아직 정렬되지 않은 부분의 첫 번째 요소를 정렬된 부분의 알맞은 위치에 삽입

1. 정렬된 열의 왼쪽 끝에 도달
2. tmp보다 작거나 같은 key를 갖는 항목 a[j]를 발견

**정렬된 부분: a[0], a[1], ... , a[i- 1]**

**정렬되지 않은 부분: a[i], a[i+ 1], ... , a[n - 1]**

**a[j - 1] > tmp: 삽입할 요소가 왼쪽의 요소들보다 작아야 한다.**

```java
static void insertSort(int[] a, int n) {
    for(int i = 1; i < n; i ++) {
        int j;
        int tmp = a[i];
        for(j = i; j > 0 && a[j - 1] > tmp; j--) {
            a[j] = a[j-1];
        }
        a[j] = tmp;
    }
}
```

* 단순 삽입 정렬은 떨어져있는 요소들이 서로 뒤바뀌지 않아 안정적이다. 비교 횟수는 n^2 / 2회





### 셸 정렬(shell sort)

단순 삽입 정렬의 장점은 살리고 단점은 보완하여 좀 더 빠르게 정렬하는 알고리즘



#### 단순 삽입 정렬의 특징

정렬을 마쳤거나 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라진다.(장점)

삽입할 위치가 멀리 떨어져 있으면 이동(대입)해야하는 횟수가 많아집니다. (단점)