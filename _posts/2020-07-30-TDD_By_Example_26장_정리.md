---
title: 빨간 막대 패턴
categories: TDD
---



빨간 막대 패턴은 테스트를 언제 어디에 작성할 것인지, 테스트 작성을 언제 멈출지에 대한 것이다.



### 한단계 테스트

목록에서 다음 테스트를 고를 때 무엇을 기준으로 할 것인가? 
-> 새로운 무언가를 가르쳐 줄 수 있으며, 구현할 수 있다는 확신이 드는 테스트를 고를 것



다음 테스트 목록 중 무엇을 고르는 게 좋을까?

* 더하기
* 빼기
* 곱하기
* 나누기
* 비슷한 것 더하기
* 동치성 (equals)
* 널과의 동치성 (equals null)
* 널 환전
* 한 개의 통화를 환전하기
* 두 개의 통화를 환전하기
* 환시세

정답은 없다. 이 목록에서 한 단계 전진을 나타낼 만한 것을 못찾았다면 직접 하나 추가해 보기를 바란다.

전체 계산 중 간단한 하나의 사례를 나타내는 테스트에서 시작했다면, 이 테스트를 통해 자라는 프로그램은 하향식으로 작성된 것으로 보일 수 있다. 반면 전체의 작은 한 조각을 나타내는 테스트에서 시작하여 조금씩 붙여나가는 식이었다면, 이 프로그램은 상향식으로 작성된 것으로 보일 수 있다.

상향식, 하향식 둘 다 TDD의 프로세스를 효과적으로 설명해 줄 수 없다.

첫째로 이와 같은 수직적 메타포는 프로그램이 시간에 따라 어떻게 변해 가는지에 대한 단순화된 시각일 뿐이다.

이보다 성장이란 단어를 보자. '성장'은 일종의 자기유사성을 가진 피드백 고리를 암시하는데, 이 피드백 고리에서는 환경이 프로그램에 영향을 주고 프로그램이 다시 환경에 영향을 준다.

둘째로, 만약 메타포가 어떤 방향성을 가질 필요가 있다면 (상향 혹은 하향보다는) '**아는 것에서 모르는 것으로(known-to-unknown)'**라는 방향이 유용할 것이다. 이는 우리가 어느 정도의 지식과 경험을 가지고 개발을 한다는 점, 개발하는 중에 새로운 것을 배우게 될 것임을 예상한다는 점 등을 암시한다.

이 두가지를 합쳐보자. 우리는 **아는 것에서 모르는 것으로 성장하는 프로그램을 갖게 된다.**



### 시작 테스트

**어떤 테스트부터 시작하는 게 좋을까?** 
**\>> 오퍼레이션이 아무 일도 하지 않는 경우를 테스트할 것.**

새 오퍼레이션에 대한 첫 질문은 다음과 같을 것이다. "이 오퍼레이션을 어디에 넣어야 하지?" 이 질문에 답하기 전까지는 테스트에 뭘 적어야할 지 알 수 없을 것이다.

한번에 한 문제만 해결하자는 의미에서 다른 질문은 다 빼고 딱 이 질문만 생각할 방법은 무엇인가?

첫 걸음으로 현실적인 테스트를 하나 작성한다면 상당히 많은 문제를 한번에 해결해야하는 상황이 될 것이다.

* 이 오퍼레이션을 어디에 두어야 하나?
* 적절한 입력 값은 무엇인가?
* 이 입력들이 주어졌을 때 적절한 출력은 무엇인가?

현실적인 테스트 하나로 시작하면 너무 오랫동안 피드백이 없을 것이다.

빨강/초록/리팩토링, 빨강/초록/리팩토링 ... 이 고리가 몇 분 이내로 반복되어야한다.

정말 발견하기 쉬운 입력과 출력을 사용하면 이 시간을 짧게 줄일 수 있다.

다각형 축소기(polygon reducer) 예를 들어보자.

입력은 다각형 그물이고, 출력은 정확하게 똑같은 표면이면서 가능한 한 최소 개수의 다각형으로 구성된 다각형 그물이 된다.

시작 테스트패턴으로 이 문제를 풀어보자.

* 출력이 입력과 같은 경우가 있다. 어떤 형상(configuration)의 다각형들은 이미 정규화되어 있고 더 축소할 수 없다.
* 입력은 가능한 한 적어야한다. 이를테면 다각형 하나 또는 아예 비어있는 다각형 목록일 수도 있다.



시작 테스트를 작성하자.

```java
Reducer reducer = new Reducer(new Polygon());
assertEquals(0, reducer.result().npoints);
```

첫 번째 테스트가 돌아간다. 이제 목록에 잇는 나머지 테스트를 처리할 차례다.

한 단계 테스트는 시작 테스트에도 적용된다. 당신에게 뭔가를 가르쳐줄 수 있으면서도 빠르게 구현할 수 있는 테스트를 선택하라. 만약 어떤 애플리케이션을 n번째 구현하고 있다면, 오퍼레이션을 한두 개 필요로 하는 테스트를 하나 골라라.

많은 경우 시작 테스트는 이 이후의 테스트에 비해 좀 더 높은 차원의 테스트로, 애플리케이션 테스트와 비슷하다.

테스트 주도로 개발하는 예 중 하나인 소켓 기반 서버를 보자.

첫번째 테스트는 다음과 같다.

```java
StartServer
Socket socket = new Socket
Message = "hello"
Socket.write(message)
AssertEquals(message, socket.read)
```

이제 나머지 테스트는 서버만으로 이루어질 수 있다. "우리가 이런 문자열을 받았다고 치고..."



### 설명 테스트

**자동화된 테스트가 더 널리 쓰이게 하려면 어떻게 해야할까?**

**\>> 테스트를 통해 설명을 요청하고 테스트를 통해 설명해라**

테스트를 통해 설명을 요청하기

* Foo를 이런 식으로 설정하고 Bar를 이런 식으로 설정하면 76이 나와야한다.

테스트를 통해 설명하기

* Foo를 이런 식으로 설정하고 Bar를 이런 식으로 설정하면 76이 나와야합니다. 그리고 Foo가 이렇고 Bar가 이러면 답은 67이 되겠죠.

이걸 더 추상적인 차원에서도 시도할 수 있다.

\>> 시퀀스 다이어그램에 나타난  모든 요소들을 포함하는 테스트 케이스를 작성하는 연습을 해보자.



### 학습 테스트

**외부에서 만든 소프트웨어에 대한 테스트를 작성해야 할 때도 있을까?**
**\>> 패키지의 새로운 기능을 처음으로 사용해보기 전에 작성할 수 있다.**

자바의 모바일 정보 기기 프로파일 (MIDP, Mobile Information Device Profile) 라이브러리를 기반으로 뭔가를 만들어야한다고 치자. Record-Store에 어떤 데이터를 저장하고 이를 받아오고자 한다.

이 라이브러리를 바로 사용하는 대신 API가 우리 예상대로 실행된다는 것을 확인해줄 만한 작은 테스트를 만들어보자.

```java
RecordStore store;
public void setUp() {
    store = RecordStore.openRecordStore("testing", true);
}
public void tearDown() {
    RecordStore.deleteRecordStore("testing");
}

public void testStore() {
    int id = store.addRecord(new byte[] {5, 6}, 0, 2);
    assertEquals(2, store.getRecordSize(id));
    
    byte[] buffer = new byte[2];
    asssertEquals(2, store.getRecord(id, buffer, 0));
    assertEquals(5, buffer[0]);
    assertEquals(6, buffer[1]);
}
```

만약 API를 제대로 이해했다면 이 테스트는 한 번에 통과될 것이다.



### 또 다른 테스트

**어떻게 하면 주제에서 벗어나지 않고 기술적인 논의를 계속할 수 있을까?**
**\>> 주제와 무관한 아이디어가 떠오르면 이에 대한 테스트를 할일 목록에 적어놓고 다시 주제로 돌아올 것.**



### 회귀 테스트

**시스템 장애가 보고될 때 무슨 일을 제일 먼저 하는가?** 
**\>> 그 장애로 인하여 실패하는 테스트, 그리고 통과할 경우엔 장애가 수정되었다고 볼 수 있는 테스트를 가장 간단**하게 작성하라.

회귀 테스트란, 사실 완벽한 선견지명이 있다면, 처음 코딩할 때 작성했어야하는 테스트다.

회귀테스트를 작성할 때는 이 테스트를 작성해야 한다는 사실을 어떻게 하면 애초에 알 수 있었을지 항상 생각해보라

전체 애플리케이션 차원에서 테스트를 수행하는 것에도 가치를 얻을 수 있다. 애플리케이션 차원의 회귀 테스트는 시스템의 사용자들이 여러분에게 정확히 무엇을 기대했으며 무엇이 잘못되었는지 말할 기회를 준다.

시스템 장애를 손쉽게 격리시킬 수 없다면 리팩토링해야한다. 이러한 종류의 장애가 있다는 것은, 아직 설계를 마무리 못했다는 뜻이다.



### 휴식

지치고 고난에 빠졌을 땐 좀 쉬자. 휴식을 통해 새로운 아이디어를 얻자. 만약 휴식으로 아이디어를 얻지 못했다면, 현재 세션의 목절을 다시 검토해보라. 여전히 현실적인가, 아니면 새로운 목적을 골라야하는가? 이루려고 노력했던 것이 불가능한 건 아닌가? 만약 그렇다면 팀에는 어떤 의미가 있나?

사워 방법론

키보드로 뭘 쳐야 할지 알면, 그걸 치고 모르면 샤워하러 가서 뭘 해야 할지 생각날 때까지 계속 샤워를 한다.

TDD에 접하자면 키보드로 뭘 쳐야할지 알면 명백한 구현을 하고 그렇지 않으면 가짜 구현을 한다.

올바른 설계가 명확하지 않다면 삼각측량 기법을 사용한다. 그래도 모르겠다면 샤워나 하러 가는 거다.

휴식 타이밍

* 시간 단위로는, 물병을 키보드 옆에 두어서 생리 현상으로 규칙적인 휴식을 하도록 유도하다.
* 하루 단위로는, 더 진행하기 전에 잠이 필요한 경우 정규 근무 시간 후의 약속이 진행을 일단 멈추는 데에 도움이 될 수 있다.
* 주 단위로는, 의식적이고 에너지 소모적인 업무 관련 생각을 떨쳐버리는 데에 주말 활동이 도움이 된다.
* 년 단위로는, 강제 휴가 정책이 재충전을 완벽히 도와줄 것이다.

하지만 휴식이 적절치 못한 상황도 있다. 때론 어려운 문제에 직면했을 때 계속 압박을 가해서 돌파해야할 경우도 있다.



### 다시 하기

**길을 잃은 느낌이 들땐 어떻게 할까?**
**\>> 코드를 다 지워버리고 처음부터 다시 해보자**



